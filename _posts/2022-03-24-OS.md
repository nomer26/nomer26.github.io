---
layout: post
title: OS
categories: [CS]
tags: [OS, kernel, precessor, processing, memory]
fullview: true
comments: true
---

## Operating System

[ OS에 대한 정의는 조금씩 차이가 있음 ]

- 사용자가 컴퓨터를 쉽게 다룰 수 있게 해주는 **인터페이스**
- 컴퓨팅 자원들을 효율적으로 관리해 사용자에게 서비스를 제공하는 **소프트웨어**
- 사용자와 하드웨어 간 중간자 역할을 수행하는 **프로그램**

<aside><pre>
💡 핵심은         <b>사용자   -  OS  -   하드웨어</b>
</pre></aside>

---
### OS 주요 기능/역할

- **리소스 관리    Concurrency**
    - 병렬 엑세스가 발생하는 경우 여러 사용자가 시스템에 접근할 때, 리소스 관리자 역할
    - 시스템의 부하를 줄이며 사용자에게 하드웨어 리소스 제공 
- **프로세스/스레드 관리**
    - 스케줄링, 프로세스 종료 등 한 번에 많은 작업들을 관리
- **스토리지 관리**
    - 파일 시스템 ( NIFS, NFS , CFS ... )
    - 모든 데이터는 스토리지 관리자가 관리하는 다양한 디스크 트랙에 저장
- **메모리 관리     Memory Management**
    - 어떤 프로세스에 얼마의 메모리가 필요한지 결정 / 할당 / 해제
- **보안/개인 정보 관리      Security**
    - 권한에 따른 접근 권한 및 리소스 할당
- **네트워크 및 분산 컴퓨팅     Networks and distributed computing**
  
- **파일 관리        File System**
    
<br><br>
    

다양한 OS 들이 출시되고 사용되고 있지만 대표적으로 알려진 OS는 <ins>UNIX / Windows</ins> 라고 생각합니다.

![UNIX OS](/assets/images/Untitled.png)

`UNIX OS`

![Windows OS](https://www.tutorialspoint.com/windows10/images/basic_features.jpg)

`Windows OS`
<br>
> **비상식    T.M.I** <br> 
 Apple Macintosh 의 성공에 영감을 받아 MS 는 MS-DOS 위에 Windows 라고 하는 그래픽 UI를 제공하기로 결정했다고 합니다.
> 
<br>

---
<center><p style="font-size:20px;"><b>UNIX 계보</b></p></center>

![UNIX 계보](/assets/images/Untitled%202.png)


---
<center><p style="font-size:15px;"><b>UNIX 구조</b></p></center>

![Unix structure](/assets/images/Untitled%203.png)

---
<center><p style="font-size:20px;"><b>Windows 계보</b></p></center>

![Windows 계보](/assets/images/Untitled%204.png)


---
<center><p style="font-size:15px;"><b>Windows 구조</b></p></center>

![Windows structure](/assets/images/Untitled%205.png)

---
## 운영체제의 구조

<ins>하드웨어 위 **Kernel**</ins>이 있고, <ins>Kernel 위 **Shell** 과 **애플리케이션**</ins>이 실행됩니다.

`사용자는 Shell 을 기반으로 애플리케이션을 실행합니다.`

### 하드웨어 (Hardware)

  물리적인 컴퓨터의 구성요소?

 대표적인 장치들을 간단히 소개하자면,

- **[CPU  (중앙 처리 장치)](/_posts/2022-03-24-Processor.md)** -  컴퓨터의 뇌 (기억, 해석, 연산, 제어 등) 와 같은 역할
- **Disk   (보조 기억 장치)** :  프로그램들을 영구적으로 저장하기 위한 저장 공간
- <b>[Memory  (주 기억 장치)](https://www.notion.so/Main-Memory-34e11eab5cb2492bb6b6f07360257ab2)</b> :  Disk 에서 가져와서 작업을 하는 공간
- **I/O    (입출력 장치)**   - 입력 : 키보드/스크린(태블릿)   출력 : 모니터/스피커 ...

### 커널 (Kernel)

- OS 핵심 부분 ( 항시 메모리 상주 )
    - 시스템 관리 ( processor , memory , etc )

  **커널**은 <ins>드라이버를 이용해서 CPU나 그래픽 카드와 같은 **하드웨어를 제어**</ins>하고 여러 응용프로그램들이 <ins>각기 다른 하드웨어 위에서 돌아갈 수 있도록 호환성을 보장하는 **API**</ins>를 제공합니다.

<aside><pre>
💡 <b>API : 정의된 프로토콜대로 상호작용 할 수 있도록 돕는 시스템</b>
</pre></aside>

---

`윈도우 커널 드라이버`

![윈도우 커널 드라이버](/assets/images/Untitled%206.png)



---

> <del style="font-size:16px;">나의 뇌피셜</del> <br>
커널 드라이버는  커널을 PCI BUS 에 장착된 장치들의 사용 정보에 맞추는 역할이라고 알고 있습니다.
>
<br>

![PCI BUS](/assets/images/Untitled%207.png)

&nbsp;&nbsp;&nbsp;`PCI BUS`

`메인보드에 부착되어  여러 장치들을 장착시키는 역할을 합니다.`

`( 그래픽 카드 , RAM ... )`

---

## OS 작업 지원

1. 편집기를 사용해 프로그램 및 데이터 파일을 생성, 수정 기능 제공
2. 고급 언어에서 기계어로 사용자 프로그램을 번역하기위해 컴파일러에 엑세스
3. 실행을 위해 컴파일된 프로그램 코드를 컴퓨터의 메모리로 이동시키는 로더 프로그램
4. I/O 프로그래밍의 세부 사항을 처리하는 루틴을 제공


### I/O 시스템 관리

<pre>
I/O 트래픽 컨트롤러  : 장치의 상태를 추적하는 모듈

I/O 하위 시스템
	- 버퍼링 캐싱 및 스풀링을 포함하는 메모리 관리 구성요소
  - 일반 장치 드라이버 인터페이스
</pre>


### 어셈블러

<pre>
어셈블리 언어 프로그램을 입력으로 받음
목적 프로그램과 로더가 실행을 위해 목적 프로그램을 준비할 수 있도록 하는 정보
=> <b>'저급 언어' 기계어로 번역    ADD X  ->  0101011000101</b> 
</pre>

### 컴파일러

<pre>
고급 언어로 FORTRAM, COBOL, ALCOL 등이 있으며 컴파일러와 인터프리터에 의해 처리
	- <b>컴파일러</b> : <b>"고급 언어"의 소스 프로그램 -> 목적 프로그램 생성  (Build)</b>,
	- <b>인터프리터</b> : 소스 프로그램을 <b>기계어처럼 실행</b>
</pre>

### 로더

<pre>
개체 프로그램을 로드하고 실행을 위해 준비하는 루틴
- 목적 프로그램을 로드, 재배치 및 링크
	=> 사용자 프로그램의 기계어 버전을 <b>메모리에 저장</b>하고 제어 전송
</pre>
---
## OS 작업 수행 방식

### **1. Batch  ( 일괄처리 )**

- <ins>동일한 요구사항을 가진 유사한 작업</ins>을 가져와 <b>일괄 처리</b>로 그룹화

![Batch](/assets/images/Untitled%208.png)

<b>장점</b>

- 작업 시간의 예측 가능
- 여러 사용자가 배치 시스템 공유
- **배치 시스템의 유휴 시간이 매우 짧음**
- **일괄 시스템에서 반복적으로 큰 작업들을 관리하기 쉬움**

<b>단점</b>

- 컴퓨터 관리자가 배치 시스템에 대해 잘 알고 있어야 함
- **디버깅이 어려움**
- **작업 실패 시 알 수 없는 시간 동안 기다려야 함**
- 소모 비용이 클 수 있음

`예 )  급여 시스템 , 은행 거래 내역서 ...`
<br><br>
### **2. Time-Sharing ( 시분할 )**

모든 작업이 원활하게 작동하도록 <ins>각 작업에 실행할 시간이 주어지며</ins>,

각 사용자는 <ins>단일 시스템을 사용하므로 CPU의 시간을 얻는 방식</ins>

- **멀티 태스킹 시스템** 이라고도 함
- 각 작업이 실행되는 시간을 <b>퀀텀</b>이라고 함
    - **<ins>이 지정 시간이 끝나면 OS는 다음 작업으로 전환함**</ins>

![Untitled](/assets/images/Untitled%209.png)

<b>장점</b>

- **각 사용자에게 기회가 평등함**
- SW 복제 가능성 감소
- **CPU 유휴 시간 감소**

<b>단점</b>

- 통신 비용 증가
- 프로그램 및 데이터의 보안과 무결성 관리
- 데이터 통신 문제
    - 동시 사용자 ↑  ▶ 시스템 부하  ↑   ▶   느려짐

`예 ) Multics , Unix ...`
<br><br>
### **3. Distributed  ( 분산 처리 )**

- 여러 CPU 를 하나의 OS 에서 운영하는데 한계가 있음 → <b>분산 처리 시스템</b>
- 다양한 자율 상호 연결된 컴퓨터는 **공유 통신 네트워크를 사용하여 통신**
- 각 독립 시스템들은 성능이 다름
- <ins>시스템에는 실제로 존재하지 않지만 네트워크에 연결된 일부 다른 시스템에 있는 파일/SW</ins>
    - 해당 네트워크에 연결된 장치 내 원격 엑세스가 활성화됨.
    
    ![Untitled](/assets/images/Untitled%2010.png)
    
    <b>장점</b>
    
    - 모든 시스템이 **서로 독립적이므로** 하나의 오류가 다른 네트워크 통신에 영향을 주지 않음 (신뢰성)
    - 전자 메일은 데이터 교환 속도를 높임.
    - **리소스를 공유하기 때문에 계산이 매우 빠르고 내구성이 있음**
    - 호스트 컴퓨터의 부하 감소
    - **데이터 처리 지연 감소**
    - 쉽게 확장할 수 있음
    
    <b>단점</b>
    
    - **주 네트워크에 장애 발생 시 전체 통신 중단**
    - 분산 시스템 구축을 위해 아직 잘 정의 되지 않은 사용 언어
    - 비용이 비싸며 기본 SW가 매우 복잡하여 이해하기 어려움
    <br><br><br><br>

### **4. Network ( 네트워크 )**
    
**서버에서 실행되며 데이터, 사용자, 그룹, 보안, 프로그램 관리**

- 소규모 사설 네트워크를 통해 공유 엑세스 허용<br><br>


![Untitled](/assets/images/Untitled%2011.png)

<b>장점</b>

- 매우 안정적인 **중앙 집중식 서버**
- 보안 문제는 서버에서 처리
- **새로운 기술과 하드웨어 업그레이드가 시스템에 쉽게 통합**
- 다양한 위치 및 시스템 유형에서 원격으로 서버에 엑세스 가능

<b>단점</b>

- 서버가 비쌈
- 사용자는 대부분의 작업을 **중앙 위치에 의존**해야 함
- 정기적으로 유지 관리 및 업데이트 필요

`예 )   MS , UNIX , Linux , Mac , BSD ...`
<br><br><br><br>

### **5. Real-Time ( 실시간 )**
    
  - **Hard Real-Time Systems**
      - <ins>시간 제약이 매우 엄격하고 가능한 짧은 지연도 허용하지 않음</ins>
      - 즉시 반응할 수 있어야 하기 때문에 <ins>가상 메모리는 사용하지 않음</ins>
          - ex) 에어백 , 자동 낙하산 ...
  <br><br>
  - **Soft Real-Time Systems**
      - **Hard Real-Time** 보다 시간 제약이 덜 엄격함
  
  ![Untitled](/assets/images/Untitled%2012.png)
  

<b>장점</b>

- 최대 소비  : 장치 및 시스템 활용도를 극대화하여 모든 리소스에서 더 많은 출력
- 작업 이동 :  작업 전환에 걸리는 시간이 매우 적음
- 애플리케이션 집중 : 현재 실행 중인 애플리케이션에 집중  ( 대기열은 후순위 )
- 오류 없음 : 시스템에 오류가 없음
- 메모리 할당 : 메모리 관리 최적화

<b>단점</b>

- 제한된 작업 : 동시에 실행되는 작업이 거의 없음
  - 오류를 피하기 위해 소수의 응용 프로그램에 집중도가 매우 낮음
- 과도한 리소스 사용 :  때때로 시스템 리소스의 소모가 크며 비용이 많이 듦
- 복잡한 알고리즘 : 알고리즘이 매우 복잡하여 작성하기 어려움
- 스레드 우선순위 : 스레드 우선 순위를 설정하는 것은 작업 전환하는 경향이 매우 적어 좋지 않음
- 장치 드라이버 및 인터럽트 신호 : 인터럽트에 빨리 응답하기 위해 특정 장치 드라이버 필요
  
  

`예 ) 과학 실험 , 의료 영상 , 무기 시스템 , 로봇, 항공 교통 관제 시스템 ...`

## OS 의 기능

### &nbsp;&nbsp;&nbsp;&nbsp;프로세스 관리

<pre>
<b>Process</b> 
- <ins>커널에서 실행중인 프로그램 단위</ins>
  
<b>생성/삭제/상태 관리
자원 할당
프로세스 간 통신/동기화
교착상태 해결</b>
</pre>
<br><br>
### 프로세서 관리

<pre>
<b>프로세스 스케줄링/자원 할당</b>
	<ins>어떤 프로세스에게 프로세서를 얼마만큼 줄것인지 결정/관리</ins>
</pre>

<br><br><br><br>

`출처`
>대부분의 자료들은 [HPC Lab. KOREATECH](https://www.youtube.com/channel/UCHvXywxOtwLedY5OX-Teg5w) 에서 가져왔습니다. <br>
이미지에 대한 출처는 미처 기록하지 못했습니다.
